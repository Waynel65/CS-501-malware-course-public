#include "aes_gcm.h"


AESGCM:: ~AESGCM(){
    Cleanup();
}

// Freebie: initialize AES class
AESGCM::AESGCM( BYTE key[AES_256_KEY_SIZE]){
    hAlg = 0;
    hKey = NULL;

    // create a handle to an AES-GCM provider
    nStatus = ::BCryptOpenAlgorithmProvider(
        &hAlg, 
        BCRYPT_AES_ALGORITHM, 
        NULL, 
        0);
    if (! NT_SUCCESS(nStatus))
    {
        printf("**** Error 0x%x returned by BCryptOpenAlgorithmProvider\n", nStatus);
        Cleanup();
        return;
    }
    if (!hAlg){
        printf("Invalid handle!\n");
    }
    nStatus = ::BCryptSetProperty(
        hAlg, 
        BCRYPT_CHAINING_MODE, 
        (BYTE*)BCRYPT_CHAIN_MODE_GCM, 
        sizeof(BCRYPT_CHAIN_MODE_GCM), 
        0);
    if (!NT_SUCCESS(nStatus)){
         printf("**** Error 0x%x returned by BCryptGetProperty ><\n", nStatus);
         Cleanup();
         return;
    }
  

    nStatus = ::BCryptGenerateSymmetricKey(
        hAlg, 
        &hKey, 
        NULL, 
        0, 
        key, 
        AES_256_KEY_SIZE, 
        0);
    if (!NT_SUCCESS(nStatus)){
        printf("**** Error 0x%x returned by BCryptGenerateSymmetricKey\n", nStatus);
        Cleanup();
        return;
    }
    DWORD cbResult = 0;
     nStatus = ::BCryptGetProperty(
         hAlg, 
         BCRYPT_AUTH_TAG_LENGTH, 
         (BYTE*)&authTagLengths, 
         sizeof(authTagLengths), 
         &cbResult, 
         0);
   if (!NT_SUCCESS(nStatus)){
       printf("**** Error 0x%x returned by BCryptGetProperty when calculating auth tag len\n", nStatus);
   }

}

// stil need to match the following parts with the code from 
// https://stackoverflow.com/questions/30720414/how-to-chain-bcryptencrypt-and-bcryptdecrypt-calls-using-aes-in-gcm-mode


void AESGCM::Decrypt(BYTE* nonce, size_t nonceLen, BYTE* data, size_t dataLen, BYTE* macTag, size_t macTagLen){
    // TODO: write this function
    // nonce = The nonce associated with this message, which must match the value provided during encryption.
    // data = The data to be decrypted.
    // macTag = The authentication tag to be verified, provided during encryption.

    plaintext = NULL;   // will be holding the decrypted result
    DWORD plainTextBufferSize = 0; // will be holding the size of the plaintext buffer
    DWORD cbResult = 0; // number of bytes that we will be receiving from decryption
    ciphertext = (BYTE*)malloc(dataLen);
    if(ciphertext == NULL){
        printf("**** Error: malloc failed\n");
        Cleanup();
        return;
    }
    memcpy(ciphertext, data, dataLen);

    // also need to initialize the BCRYPT_AUTH_TAG_LENGTHS_STRUCT for decryption
    BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo;
    BCRYPT_INIT_AUTH_MODE_INFO(authInfo);
    authInfo.pbNonce = nonce;
    authInfo.cbNonce = nonceLen;
    authInfo.pbTag = macTag;
    authInfo.cbTag = macTagLen;
    
    // decrypt the data
    nStatus = ::BCryptDecrypt(
        hKey, 
        ciphertext, 
        dataLen, 
        NULL, 
        nonce, 
        nonceLen, 
        NULL, 
        0, 
        &plainTextBufferSize, 
        BCRYPT_BLOCK_PADDING);
    
    if (!NT_SUCCESS(nStatus)){
        printf("**** Error 0x%x returned by BCryptDecrypt\n", nStatus);
        Cleanup();
        return;
    }

    // allocate memory for plaintext
    plaintext = (BYTE*)malloc(plainTextBufferSize);

    // decrypt the data
    nStatus = ::BCryptDecrypt(
        hKey, 
        ciphertext, 
        dataLen, 
        NULL, 
        nonce, 
        nonceLen, 
        plaintext, 
        cbResult, 
        &cbResult, 
        BCRYPT_BLOCK_PADDING);
    if (!NT_SUCCESS(nStatus)){
        printf("**** Error 0x%x returned by BCryptDecrypt\n", nStatus);
        Cleanup();
        return;
    }

    Cleanup();
    return;

}

// need to change the variables in this function to match with the provided attributes in this class
void AESGCM::Encrypt(BYTE* nonce, size_t nonceLen, BYTE* data, size_t dataLen){

    // missing tag structure

    // free buffers (NOT SURE IF THIS IS NEEDED)
    // free(plaintext);
    plaintext = NULL;
    // free(ciphertext);
    ciphertext = NULL;
   
   DWORD cipherBuffSize = 0; // buffersize to hold the result
   // allocate a heap buffer to hold the incoming data
   plaintext = (BYTE*)malloc(dataLen);
   if(plaintext == NULL){
       printf("Error allocating heap buffer for incoming data\n");
       Cleanup();
       return;
   }
    memcpy(plaintext, data, dataLen);

    // intialization for BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
    // std::vector<BYTE> authTag(authTagLengths.dwMinLength);

    BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo;
    BCRYPT_INIT_AUTH_MODE_INFO(authInfo);
    authInfo.pbNonce = nonce;
    authInfo.cbNonce = nonceLen;
    authInfo.pbTag = tag;
    authInfo.cbTag = authTagLengths.dwMinLength;
    authInfo.pbAuthData = NULL;
    authInfo.cbAuthData = 0;
    authInfo.pbMacContext = NULL;
    authInfo.cbMacContext = 0;
    authInfo.cbAAD = 0;
    authInfo.cbData = 0;

    // set pdAuthdata and cdAuthdata before calling BCryptEncrypt??

    nStatus = ::BCryptEncrypt(
        hKey, // the handle of the key to use for encryption, obtained from BCryptGenerateSymmetricKey
        plaintext, // the pointer to the data to be encrypted
        dataLen, 
        &authInfo, 
        nonce, // IV(initialization vector) to use for encryption
        nonceLen, 
        NULL, // set to NULL to activate bufferSize calculation mode
        0,
        &cipherBuffSize, 
        BCRYPT_BLOCK_PADDING);
    if (!NT_SUCCESS(nStatus)){
        printf("**** first Error 0x%x returned by BCryptEncrypt\n", nStatus);
        Cleanup();
        return;
    }

    // allocate a buffer to hold the result
    ciphertext = (BYTE*)malloc(cipherBuffSize);
    if(ciphertext == NULL){
        printf("allocating heap buffer for ciphertext\n");
        Cleanup();
        return;
    }

    DWORD cbResult = 0; // receives the number of bytes copied to the ciphertext buffer
    nStatus = ::BCryptEncrypt(
        hKey, // the handle of the key to use for encryption, obtained from BCryptGenerateSymmetricKey
        plaintext, // the pointer to the data to be encrypted
        dataLen, 
        &authInfo, 
        nonce, // IV(initialization vector) to use for encryption
        nonceLen, 
        ciphertext, // the pointer to the buffer to hold the result
        cipherBuffSize, // the size of the buffer to hold the result
        &cbResult, 
        BCRYPT_BLOCK_PADDING);
    
    if (!NT_SUCCESS(nStatus)){
        printf("**** second Error 0x%x returned by BCryptEncrypt\n", nStatus);
        Cleanup();
        return;
    }

    // dont want to cleanup here otherwise ciphertext will be freed

}

void AESGCM::Cleanup(){
    if(hAlg){
        ::BCryptCloseAlgorithmProvider(hAlg,0);
        hAlg = NULL;
    }
    if(hKey){
        ::BCryptDestroyKey(hKey);
        hKey = NULL;
    }
    if(tag){
        //   ::HeapFree(GetProcessHeap(), 0, tag);
          tag = NULL;
    }
    if(ciphertext){
        // ::HeapFree(GetProcessHeap(), 0, tag);
        free(ciphertext);
        ciphertext = NULL;
    }
    if(plaintext){
        // ::HeapFree(GetProcessHeap(), 0, plaintext);
        free(plaintext);
        plaintext = NULL;
    }
}