#include <string>
#include <windows.h>

class BaseCommand
{
    int opcode;
    std::string name;
public:
    //= 0 means derived classes must provide an implementation, 
    // not that the base class can not provide an implementation.
    BaseCommand(){
        // Nop
    }
    ~BaseCommand(){
        //nop
    }
    virtual std::string Execute( std::string args) = 0;
    virtual int getOpcode() = 0;
    virtual std::string getName() = 0;
     
};
  

  class ExecuteGetUserName: public BaseCommand{
      #define EXECUTE_GET_USERNAME_OPCODE 16
    public:
    int getOpcode() {return EXECUTE_GET_USERNAME_OPCODE;}
    std::string getName() {return "GetUserName";}
    std::string Execute(std::string args){
        // no args needed 
        DWORD dwBuffSize = MAX_PATH;
        std::string buffer (dwBuffSize, '\0');

        BOOL bRes = ::GetUserNameA(&buffer[0],&dwBuffSize );
        if(!bRes){
            std::string res = "Failed to get result because of " + std::to_string(::GetLastError());
            printf("error: %s\n", res.c_str());
            return res;
        }
        printf("Username:  %s\n", buffer.c_str());
        return buffer;
    }

  };

BaseCommand* CommandFactory(int opcode){
    switch(opcode){
        case EXECUTE_GET_USERNAME_OPCODE:
            return new ExecuteGetUserName();
            break;
        default:
            return nullptr;
            break;
    }

}

  int main(){
    int opcode = EXECUTE_GET_USERNAME_OPCODE;
    BaseCommand *command = NULL;
    std::string args = "";
    switch(opcode){
        case EXECUTE_GET_USERNAME_OPCODE:
            command = new ExecuteGetUserName();
            command->Execute("");
            printf("Function: %s:%d\n", command->getName().c_str(), command->getOpcode());
            break;
        default:
            printf("Not implemented!\n");
            break;

    };
    
    printf("Factory Pattern...\n");
    BaseCommand* factory = CommandFactory(16);
    factory->Execute("");
    
    
    return 0;

  }